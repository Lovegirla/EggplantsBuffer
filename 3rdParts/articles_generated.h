// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ARTICLES_ARTICLEDATA_H_
#define FLATBUFFERS_GENERATED_ARTICLES_ARTICLEDATA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace ArticleData {

struct CAnswer;
struct CAnswerBuilder;

struct QASData;
struct QASDataBuilder;

struct Paragraph;
struct ParagraphBuilder;

struct Article;
struct ArticleBuilder;

struct Articles;
struct ArticlesBuilder;

struct CAnswer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CAnswerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANSWER_START = 4,
    VT_TEXT = 6
  };
  int32_t answer_start() const {
    return GetField<int32_t>(VT_ANSWER_START, 0);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ANSWER_START, 4) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct CAnswerBuilder {
  typedef CAnswer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_answer_start(int32_t answer_start) {
    fbb_.AddElement<int32_t>(CAnswer::VT_ANSWER_START, answer_start, 0);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(CAnswer::VT_TEXT, text);
  }
  explicit CAnswerBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CAnswer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CAnswer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CAnswer> CreateCAnswer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t answer_start = 0,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0) {
  CAnswerBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_answer_start(answer_start);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CAnswer> CreateCAnswerDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t answer_start = 0,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return ArticleData::CreateCAnswer(
      _fbb,
      answer_start,
      text__);
}

struct QASData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QASDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_QUESTION = 6,
    VT_ANSWERS = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *question() const {
    return GetPointer<const ::flatbuffers::String *>(VT_QUESTION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::CAnswer>> *answers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::CAnswer>> *>(VT_ANSWERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_QUESTION) &&
           verifier.VerifyString(question()) &&
           VerifyOffset(verifier, VT_ANSWERS) &&
           verifier.VerifyVector(answers()) &&
           verifier.VerifyVectorOfTables(answers()) &&
           verifier.EndTable();
  }
};

struct QASDataBuilder {
  typedef QASData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(QASData::VT_ID, id);
  }
  void add_question(::flatbuffers::Offset<::flatbuffers::String> question) {
    fbb_.AddOffset(QASData::VT_QUESTION, question);
  }
  void add_answers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::CAnswer>>> answers) {
    fbb_.AddOffset(QASData::VT_ANSWERS, answers);
  }
  explicit QASDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QASData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QASData>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QASData> CreateQASData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> question = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::CAnswer>>> answers = 0) {
  QASDataBuilder builder_(_fbb);
  builder_.add_answers(answers);
  builder_.add_question(question);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<QASData> CreateQASDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *question = nullptr,
    const std::vector<::flatbuffers::Offset<ArticleData::CAnswer>> *answers = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto question__ = question ? _fbb.CreateString(question) : 0;
  auto answers__ = answers ? _fbb.CreateVector<::flatbuffers::Offset<ArticleData::CAnswer>>(*answers) : 0;
  return ArticleData::CreateQASData(
      _fbb,
      id__,
      question__,
      answers__);
}

struct Paragraph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParagraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTEXT = 4,
    VT_QASDATA = 6
  };
  const ::flatbuffers::String *context() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTEXT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::QASData>> *qasData() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::QASData>> *>(VT_QASDATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTEXT) &&
           verifier.VerifyString(context()) &&
           VerifyOffset(verifier, VT_QASDATA) &&
           verifier.VerifyVector(qasData()) &&
           verifier.VerifyVectorOfTables(qasData()) &&
           verifier.EndTable();
  }
};

struct ParagraphBuilder {
  typedef Paragraph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_context(::flatbuffers::Offset<::flatbuffers::String> context) {
    fbb_.AddOffset(Paragraph::VT_CONTEXT, context);
  }
  void add_qasData(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::QASData>>> qasData) {
    fbb_.AddOffset(Paragraph::VT_QASDATA, qasData);
  }
  explicit ParagraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Paragraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Paragraph>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Paragraph> CreateParagraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> context = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::QASData>>> qasData = 0) {
  ParagraphBuilder builder_(_fbb);
  builder_.add_qasData(qasData);
  builder_.add_context(context);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Paragraph> CreateParagraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *context = nullptr,
    const std::vector<::flatbuffers::Offset<ArticleData::QASData>> *qasData = nullptr) {
  auto context__ = context ? _fbb.CreateString(context) : 0;
  auto qasData__ = qasData ? _fbb.CreateVector<::flatbuffers::Offset<ArticleData::QASData>>(*qasData) : 0;
  return ArticleData::CreateParagraph(
      _fbb,
      context__,
      qasData__);
}

struct Article FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArticleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TITLE = 4,
    VT_PARAGRAPHS = 6
  };
  const ::flatbuffers::String *title() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TITLE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::Paragraph>> *paragraphs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::Paragraph>> *>(VT_PARAGRAPHS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TITLE) &&
           verifier.VerifyString(title()) &&
           VerifyOffset(verifier, VT_PARAGRAPHS) &&
           verifier.VerifyVector(paragraphs()) &&
           verifier.VerifyVectorOfTables(paragraphs()) &&
           verifier.EndTable();
  }
};

struct ArticleBuilder {
  typedef Article Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_title(::flatbuffers::Offset<::flatbuffers::String> title) {
    fbb_.AddOffset(Article::VT_TITLE, title);
  }
  void add_paragraphs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::Paragraph>>> paragraphs) {
    fbb_.AddOffset(Article::VT_PARAGRAPHS, paragraphs);
  }
  explicit ArticleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Article> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Article>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Article> CreateArticle(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> title = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::Paragraph>>> paragraphs = 0) {
  ArticleBuilder builder_(_fbb);
  builder_.add_paragraphs(paragraphs);
  builder_.add_title(title);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Article> CreateArticleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *title = nullptr,
    const std::vector<::flatbuffers::Offset<ArticleData::Paragraph>> *paragraphs = nullptr) {
  auto title__ = title ? _fbb.CreateString(title) : 0;
  auto paragraphs__ = paragraphs ? _fbb.CreateVector<::flatbuffers::Offset<ArticleData::Paragraph>>(*paragraphs) : 0;
  return ArticleData::CreateArticle(
      _fbb,
      title__,
      paragraphs__);
}

struct Articles FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArticlesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARTICLES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::Article>> *articles() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::Article>> *>(VT_ARTICLES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARTICLES) &&
           verifier.VerifyVector(articles()) &&
           verifier.VerifyVectorOfTables(articles()) &&
           verifier.EndTable();
  }
};

struct ArticlesBuilder {
  typedef Articles Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_articles(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::Article>>> articles) {
    fbb_.AddOffset(Articles::VT_ARTICLES, articles);
  }
  explicit ArticlesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Articles> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Articles>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Articles> CreateArticles(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ArticleData::Article>>> articles = 0) {
  ArticlesBuilder builder_(_fbb);
  builder_.add_articles(articles);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Articles> CreateArticlesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ArticleData::Article>> *articles = nullptr) {
  auto articles__ = articles ? _fbb.CreateVector<::flatbuffers::Offset<ArticleData::Article>>(*articles) : 0;
  return ArticleData::CreateArticles(
      _fbb,
      articles__);
}

inline const ArticleData::Articles *GetArticles(const void *buf) {
  return ::flatbuffers::GetRoot<ArticleData::Articles>(buf);
}

inline const ArticleData::Articles *GetSizePrefixedArticles(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ArticleData::Articles>(buf);
}

inline bool VerifyArticlesBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ArticleData::Articles>(nullptr);
}

inline bool VerifySizePrefixedArticlesBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ArticleData::Articles>(nullptr);
}

inline void FinishArticlesBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ArticleData::Articles> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedArticlesBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ArticleData::Articles> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace ArticleData

#endif  // FLATBUFFERS_GENERATED_ARTICLES_ARTICLEDATA_H_
